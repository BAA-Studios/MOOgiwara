/*
* This file represents a player within a game
*/
import { Socket } from "socket.io";
import { SyncCardList } from "../game/sync_card_list";
import { Card } from "../game/card";
import { identifyLeaderCard } from "../util/utils";
import Game from "../game/game";
import { playCard } from "../cards/card_engine";
import { IPlayerData } from "../database/player_data_model";


export default class Player {
  client: Socket;
  username: string | undefined;  // full name if registered user; else, autogenerated name
  socketId: string;  
  lobbyId: string | undefined;  // socketId of the player that started the game
  playerId: string | undefined;
  playerData: IPlayerData | undefined;
  
  game: Game | undefined = undefined;
  boardReady = false; // Stores information about whether the client has finished rendering the board
  mulligan = false; // Stores information about whether the client has finished mulliganing

  // Private info to the player
  deck: SyncCardList;
  lifeCards: SyncCardList = new SyncCardList("lifeCards");

  // Public info to the player
  leader: Card | undefined = undefined;
  characterArea: SyncCardList = new SyncCardList("characterArea");
  donDeck: SyncCardList = new SyncCardList("donDeck");
  donArea: SyncCardList = new SyncCardList("donArea");
  hand: SyncCardList = new SyncCardList("hand");
  trash: SyncCardList = new SyncCardList("trash");

  constructor(client: Socket, socketId: string, deckList: string[]) {
    this.client = client;
    this.socketId = socketId;
  
    let tempLeaderId = "";
    for (let card of deckList) {
      if (identifyLeaderCard(card)) {
        tempLeaderId = card;
        this.leader = new Card(card);
        // Remove the leader card from the deck
        deckList.splice(deckList.indexOf(card), 1);
        break;
      }
    }
    this.deck = new SyncCardList("deck", deckList);
    deckList.push(tempLeaderId);

    // Init the don deck with 10 don cards
    for (let i = 0; i < 10; i++) {
      const card = new Card("donCardAltArt");
      this.donDeck.push(card);
    }
  }

  /*
  * This function initializes the listeners to client requests
  */
  initListeners() {
    this.client.on("drawCard", (amount: number, callback) => {
      console.log(`[INFO] Player ${this.username ?? this.socketId} requested to draw ${amount} card(s)`);
      this.drawCard(amount);

      callback({
        cards: this.hand.cards(),
        type: this.hand.type
      });

      // Update the opponent's client
      this.game?.broadcastPacketExceptSelf("opponentDrawCard", { 
        amount: amount,
      }, this);
    });

    this.client.on("drawDon", (data) => {
      let amount = data.amount;
      console.log(`[INFO] Player ${this.username ?? this.socketId} requested to draw ${amount} Don!!`);
      if (this.donDeck.size() === 0) { 
        return;
      }
      let serverAmountCalculated = this.drawDon(amount);
      this.game?.broadcastPacketExceptSelf("opponentDrawDon", {
        amount: serverAmountCalculated,
      }, this);
    });

    this.client.on("shuffleHandToDeck", () => {
      console.log(`[INFO] Player ${this.username ?? this.socketId} requested to shuffle hand to deck`);
      this.shuffleHandToDeck();
    });

    this.client.on('shuffleDeck', () => {
      console.log(`[INFO] Player ${this.username ?? this.socketId} requested to shuffle deck`);
      this.deck.shuffle();
    });

    this.client.on('endTurn', () => {
      console.log(`[INFO] Player ${this.username ?? this.socketId} requested to end turn`);
      this.game?.broadcastChat(`${this.username ?? this.socketId} ended their turn.`);
      this.game?.changeTurn();
    });

    this.client.on('playCard', (data) => {
      let cardPlayed = this.hand.get(data.index);
      if (cardPlayed === undefined) {
        console.log(`[ERROR] Player ${this.username ?? this.socketId} tried to play a card that doesn't exist`);
        return;
      }
      console.log(`[INFO] Player ${this.username ?? this.socketId} requested to play card ${cardPlayed.name}`);
      // send card to the card engine to determine how it should be played.
      playCard(this, cardPlayed);
    });

    this.client.on('refreshPhase', () => {
      console.log(`[INFO] Player ${this.username ?? this.socketId} requested to refresh their board (Refresh Phase))`);
      // Check the game if it is the player's turn
      if (!this.game?.playersTurn(this)) {
        return;
      }
      // Unrest all cards and return any attached dons to the don deck
      this.characterArea.list().forEach((card) => {
        card.isResting = false;
        card.summoningSickness = false;
        for (let i = 0; i < card.attachedDon.size(); i++) {
          this.donArea.push(card.attachedDon.getElementByPos(i));
        }
        card.clearDon();
      });

      if (this.game?.turnNumber === 2 || this.game?.turnNumber === 3) {
        if (this.leader) {
          this.leader.summoningSickness = false;
        }
      }

      // Return dons from leader to don area
      this.leader?.attachedDon.forEach((don) => {
        this.donArea.push(don);
      });

      // unrest leader
      if (this.leader !== undefined) {
        this.leader.isResting = false;
      }

      this.leader?.clearDon();
      this.updateLeaderForOpponent();
      
      this.characterArea.update(this.client);
      this.updateCharacterAreaForOpponent()
      this.donArea.list().forEach((card) => {
        card.isResting = false;
      });
      this.donArea.update(this.client);
      this.updateDonAreaForOpponent();
    });

    this.client.on("deckCount", (_, callback: Function) => {
      let count = this.deck.size();
      console.log(`[INFO] Player ${this.username ?? this.socketId} requested to know the size of their deck`)
      callback(count);
    });

    this.client.on("attachDon", (cardIndex: number, callback: Function) => {
      let cardAttachedTo: Card | undefined;
      if (cardIndex === -1) { // Is leader card
        cardAttachedTo = this.leader;
      } else {
        cardAttachedTo = this.characterArea.get(cardIndex);
      }

      if (!cardAttachedTo) {
        console.log(`[ERROR] Player ${this.username ?? this.socketId} tried to attach a don to a card that doesn't exist`);
        return;
      }

      // Check if player has enough don in the don area to attach
      if (this.donArea.size() === 0) {
        console.log(`[ERROR] Player ${this.username ?? this.socketId} tried to attach a don to a card but they don't have any don in their don area`);
        return;
      }

      console.log(`[INFO] Player ${this.username ?? this.socketId} requested to attach a Don!! to character ${cardAttachedTo?.name}`);
      // Remove the last unrested don from the don area
      for (let i = this.donArea.size() - 1; i >= 0; i--) {
        let don = this.donArea.get(i);
        if (!don.isResting) {
          cardAttachedTo.addDon(don);
          this.donArea.remove(don);
          break;
        }
      }
      callback(this.donArea.list());
      this.updateDonAreaForOpponent();

      if (cardIndex === -1) {
        this.updateLeaderForOpponent();
      } else {
        this.updateCharacterAreaForOpponent();
      }

      // Broadcast the don attached to the opponent
      this.game?.broadcastChat(`${this.username} attached a Don!! \nto "${cardAttachedTo.name}"`);
    });

    this.client.on("retireCard", (cardIndexInPlay: number, cardindexInContainer: number,  callback: Function) => {
      let cardRetired: Card | undefined;
      cardRetired = this.characterArea.get(cardIndexInPlay);
      let cardInHand = this.hand.get(cardindexInContainer);

      if (this.characterArea.size() !== 5) {
        console.log(`[ERROR] Player ${this.username ?? this.socketId} tried to retire a card when they don't have 5 cards in play`);
        return;
      }

      if (!cardInHand) {
        console.log(`[ERROR] Player ${this.username ?? this.socketId} tried to replace a card with a card that doesn't exist`);
        return;
      }

      if (!cardRetired) {
        console.log(`[ERROR] Player ${this.username ?? this.socketId} tried to replace a card that doesn't exist`);
        return;
      }

      if (cardInHand.isEventCard()) {
        console.log(`[ERROR] Player ${this.username ?? this.socketId} tried to replace a card with an event card`);
        return;
      }

      console.log(`[INFO] Player ${this.username ?? this.socketId} requested to retire character: "${cardRetired?.name}" with character: "${cardInHand?.name}"`);
      // Remove the card from player's hand
      this.hand.remove(cardInHand);
      // Insert this card into the character area
      this.characterArea.insertAt(cardIndexInPlay, cardInHand);
      // Remove the original card from the character area
      this.characterArea.remove(cardRetired);
      // Check for any attached Don!! and return it to the donArea rested
      cardRetired.attachedDon.forEach((don) => {
        don.isResting = true;
        this.donArea.push(don);
      });
      cardRetired.clearDon();

      this.restDon(cardInHand.cost, false);
      cardInHand.summoningSickness = true;

      // Add it to the trash
      this.trash.push(cardRetired);

      callback(this.characterArea.list(), this.donArea.list(), this.hand.list(), this.trash.list());

      // Update every area for opponent
      this.updateCharacterAreaForOpponent();
      this.sendRemoveCardFromHandPacketToOpponent(1);
      this.updateDonAreaForOpponent();
      this.updateTrashAreaForOpponent();

      this.game?.broadcastChat(`${this.username} retired "${cardRetired.name}" \nand replaced it with "${cardInHand.name}"`);
    });

    this.client.on("initiateAttack", (
      cardAttackingisLeader: boolean, 
      cardAttackingIndex: number,
      cardDefendingisLeader: boolean,
      cardDefendingIndex: number,
      sendBlockerIndex: Function) => {
        console.log(`[INFO] Player ${this.username ?? this.socketId} requested to initiate an attack on card ${cardDefendingIndex}`);
        let cardDefending = this.game?.getOpponent(this)?.leader;
        if (!cardDefendingisLeader) {
          cardDefending = this.game?.getOpponent(this)?.characterArea.get(cardDefendingIndex);
        }
        if (!cardDefending) {
          console.log(`[ERROR] Player ${this.username ?? this.socketId} tried to initiate an attack on a card that doesn't exist`);
          return;
        }

        // Set the attacking card to resting
        if (!cardAttackingisLeader) {
          let cardAttacking = this.characterArea.get(cardAttackingIndex);
          if (!cardAttacking) {
            console.log(`[ERROR] Player ${this.username ?? this.socketId} tried to initiate an attack with a card that doesn't exist`);
            return;
          }
          cardAttacking.isResting = true;
        } else {
          if (this.leader) {
            this.leader.isResting = true;
          }
        }

        this.game?.broadcastChat(`${this.username} initiated an attack\non card "${cardDefending.name}"`);
        let opponent = this.game?.getOpponent(this);
        opponent?.client.emit("opponentInitiateAttack", {
          cardAttackingIsLeader: cardAttackingisLeader,
          cardAttackingIndex: cardAttackingIndex,
          cardDefendingIsLeader: cardDefendingisLeader,
          cardDefendingIndex: cardDefendingIndex
        }, (blockerIndex: number) => {
          if (blockerIndex === -3) {
            this.game?.broadcastChat(`${opponent?.username} skipped block.`);
            return;
          }
          let cardDefending = opponent?.characterArea.get(blockerIndex);
          if (!cardDefending) {
            console.log(`[ERROR] Player ${opponent?.username ?? opponent?.socketId} tried to block an attack with a card that doesn't exist`);
            return;
          }
          cardDefending.isResting = true;
          this.game?.broadcastChat(`${opponent?.username} blocked the attack\nwith card "${cardDefending.name}"`);
          console.log(`[INFO] Player ${opponent?.username ?? opponent?.socketId} blocked the attack with card ${cardDefending.name}`);
          sendBlockerIndex(blockerIndex);
        });
    });
  }

  setUsername(username: string): void {
    this.username = username;
  }

  setLobbyId(lobbyId: string): void {
    this.lobbyId = lobbyId;
  }

  setPlayerId(playerId: string): void {
    this.playerId = playerId;
  }

  setPlayerData(playerData: IPlayerData): void {
    this.playerData = playerData;
  }

  drawCard(amount: number = 1) {
    for (let i = 0; i < amount; i++) {
      if (this.deck.size() === 0) {
        break;
      }
      const card = this.deck.popTopCard();
      this.hand.push(card);
    }
  }

  drawDon(amount: number = 1) {
    let cardsDrawn = 0;
    for (let i = 0; i < amount; i++) {
      if (this.donDeck.size() === 0) {
        break;
      }
      const card = this.donDeck.popTopCard();
      this.donArea.push(card);
      cardsDrawn++;
    }

    this.donArea.update(this.client);
    return cardsDrawn;
  }

  removeCardFromHand(index: number) {
    let cardRemoved = this.hand.removeAt(index);
    // Update the client's hand
    this.hand.update(this.client);

    // Update the opponent's client
    this.game?.broadcastPacketExceptSelf("opponentRemoveCardFromHand", {
      amount: 1,
    }, this);
    return cardRemoved;
  }

  shuffleHandToDeck() {
    // Update the opponent's client
    this.game?.broadcastPacketExceptSelf("opponentRemoveCardFromHand", {
      amount: this.hand.size(),
    }, this);

    while(!this.hand.empty()) {
      this.deck.push(this.hand.popTopCard());
    }
    this.deck.shuffle();

    // Update the client's hand
    this.hand.update(this.client);
  }

  setLifeCards() {
    if (this.leader === undefined) {
      return;
    }
    for (let i = 0; i < this.leader.life; i++) {
      this.lifeCards.push(this.deck.popTopCard());
    }
  }

  getHeathLeft() {
    return this.lifeCards.size();
  }

  getUnrestedDonLeft() {
    let unrestedDon = 0;
    for (let card of this.donArea.list()) {
      if (!card.isResting) {
        unrestedDon++;
      }
    }
    return unrestedDon;
  }

  getDonTotal() {
    return this.donArea.size();
  }

  restDon(amount: number = 1, update: boolean = true) {
    let unrestedDon = this.getUnrestedDonLeft();
    if (unrestedDon === 0) {
      return;
    }
    if (amount > unrestedDon) {
      amount = unrestedDon;
    }
    // Rest the cards starting from the back of the list
    for (let i = this.donArea.size() - 1; i >= 0; i--) {
      let card = this.donArea.get(i);
      if (card === undefined) {
        continue;
      }
      if (!card.isResting && amount > 0) {
        card.isResting = true;
        amount--;
      }
    }
    if (update) { 
      this.donArea.update(this.client);
     }
  }

  setSummoningSickness() {
    for (let card of this.characterArea.list()) {
      card.summoningSickness = false;
    }
  }

  updateLeaderForOpponent() {
    this.game?.broadcastPacketExceptSelf("opponentUpdateLeader", {
      card: this.leader
    }, this);
  }

  updateCharacterAreaForOpponent() {
    this.game?.broadcastPacketExceptSelf("opponentUpdateCharacterArea", {
      cards: this.characterArea.list()
    }, this);
  }

  updateDonAreaForOpponent() {
    this.game?.broadcastPacketExceptSelf("opponentUpdateDonArea", {
      cards: this.donArea.list()
    }, this);
  }

  sendRemoveCardFromHandPacketToOpponent(amount: number) {
    this.game?.broadcastPacketExceptSelf("opponentRemoveCardFromHand", {
      amount: amount
    }, this);
  }

  updateTrashAreaForOpponent() {
    this.game?.broadcastPacketExceptSelf("opponentUpdateTrash", {
      cards: this.trash.list()
    }, this);
  }

  sendOpponentAttackingPacket(cardAttackingIsLeader: boolean, 
    cardAttackingIndex: number, 
    cardDefendingIsLeader: boolean,
    cardDefendingIndex: number) {
    this.game?.broadcastPacketExceptSelf("opponentInitiateAttack", {
      cardAttackingIsLeader: cardAttackingIsLeader,
      cardAttackingIndex: cardAttackingIndex,
      cardDefendingIsLeader: cardDefendingIsLeader,
      cardDefendingIndex: cardDefendingIndex
    }, this);
  }

  sendNotification(message: string, color: number) {
    this.client?.emit("notification", message, color);
  }
}
